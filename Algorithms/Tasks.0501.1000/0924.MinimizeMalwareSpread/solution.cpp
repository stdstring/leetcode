#include <algorithm>
#include <queue>
#include <vector>

#include "gtest/gtest.h"

namespace
{

class Solution
{
public:
    [[nodiscard]] int minMalwareSpread(std::vector<std::vector<int>> const &graph, std::vector<int> const &initial) const
    {
        const int nodesCount = static_cast<int>(graph.size());
        std::vector<std::vector<int>> nodes(nodesCount);
        for (int node = 0; node < nodesCount; ++node)
        {
            for (int otherNode = 0; otherNode < nodesCount; ++otherNode)
            {
                if ((node == otherNode) || (graph[node][otherNode] == 0))
                    continue;
                nodes[node].emplace_back(otherNode);
            }
        }
        int minMalwareSpreadValue = INT_MAX;
        int excludedNode = INT_MAX;
        for (size_t index = 0; index < initial.size(); ++index)
        {
            const int currentMalwareSpreadValue = calcMalwareSpread(nodes, initial, index);
            if (currentMalwareSpreadValue <= minMalwareSpreadValue)
            {
                excludedNode = std::min((currentMalwareSpreadValue == minMalwareSpreadValue) ? excludedNode : INT_MAX, initial[index]);
                minMalwareSpreadValue = currentMalwareSpreadValue;
            }
        }
        return excludedNode;
    }

private:
    [[nodiscard]] int calcMalwareSpread(std::vector<std::vector<int>> const &nodes, std::vector<int> const &initial, size_t excluded) const
    {
        int finalCount = static_cast<int>(initial.size()) - 1;
        std::vector<bool> visited(nodes.size(), false);
        std::queue<int> nodesQueue;
        for (size_t index = 0; index < initial.size(); ++index)
        {
            if (index == excluded)
                continue;
            nodesQueue.emplace(initial[index]);
            visited[initial[index]] = true;
        }
        while (!nodesQueue.empty())
        {
            const int current = nodesQueue.front();
            nodesQueue.pop();
            for (const int neighbor : nodes[current])
            {
                if (visited[neighbor])
                    continue;
                nodesQueue.emplace(neighbor);
                visited[neighbor] = true;
                ++finalCount;
            }
        }
        return finalCount;
    }
};

}

namespace MinimizeMalwareSpreadTask
{

TEST(MinimizeMalwareSpreadTaskTests, Examples)
{
    constexpr Solution solution;
    ASSERT_EQ(0, solution.minMalwareSpread({{1, 1, 0}, {1, 1, 0}, {0, 0, 1}}, {0, 1}));
    ASSERT_EQ(0, solution.minMalwareSpread({{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}, {0, 2}));
    ASSERT_EQ(1, solution.minMalwareSpread({{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, {1, 2}));
}

TEST(MinimizeMalwareSpreadTaskTests, FromWrongAnswers)
{
    constexpr Solution solution;
    ASSERT_EQ(3, solution.minMalwareSpread({{1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 1}, {0, 0, 1, 1}}, {3, 1}));
    ASSERT_EQ(2, solution.minMalwareSpread({{1, 1, 0}, {1, 1, 0}, {0, 0, 1}}, {0, 1, 2}));
    ASSERT_EQ(2, solution.minMalwareSpread({{1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
                                            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0},
                                            {0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0},
                                            {0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
                                            {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
                                            {0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0},
                                            {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
                                            {0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0},
                                            {0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0},
                                            {0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0},
                                            {1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}, {7, 8, 6, 2, 3}));
}

}